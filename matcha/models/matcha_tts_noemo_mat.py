import datetime as dt
import math
import random

import torch

import matcha.utils.monotonic_align as monotonic_align
from matcha import utils


# æ³¨æ„è¿™é‡Œæ˜¯ç»§æ‰¿è‡ªbaselightningmodule_noemoï¼Œè¿™é‡Œé¢ä¹Ÿå†™äº†å¾ˆå¤šå…³äºæ¨¡å‹éœ€è¦çš„å‡½æ•°ã€‚
from matcha.models.baselightningmodule_noemo import BaseLightningClass
from matcha.models.components.flow_matching_mat import CFM

# æ³¨æ„è¿™é‡Œæ˜¯æ²¡æœ‰emoå‘é‡æƒ³åŠ çš„textencoder
from matcha.models.components.text_encoder_noemo import TextEncoder
from matcha.utils.model import (
    denormalize,
    duration_loss,
    fix_len_compatibility,
    generate_path,
    sequence_mask,
)

log = utils.get_pylogger(__name__)




# è¿™é‡Œçš„ç±»æ˜¯ç»§æ‰¿è‡ªBaseLightningClassï¼Œé‡Œé¢å†™äº†ä¸€äº›PLæ‰€å¿…é¡»çš„å‡½æ•°
# ç»§æ‰¿ä»¥åï¼Œè¿™é‡Œä¸»è¦å®ç°äº†initå’Œforwardå‡½æ•°ï¼Œè¿”å›loss
class MatchaTTS(BaseLightningClass):  # ğŸµ
    def __init__(
        self,
        n_vocab,
        n_spks,
        spk_emb_dim,
        n_feats,
        encoder,
        decoder,
        cfm,
        data_statistics,
        out_size,
        optimizer=None,
        scheduler=None,
        prior_loss=True,
        use_precomputed_durations=False,
    ):
        super().__init__()

        self.save_hyperparameters(logger=False)

        self.n_vocab = n_vocab
        self.n_spks = n_spks
        self.spk_emb_dim = spk_emb_dim
        self.n_feats = n_feats
        self.out_size = out_size
        self.prior_loss = prior_loss
        self.use_precomputed_durations = use_precomputed_durations

        if n_spks > 1:
            self.spk_emb = torch.nn.Embedding(n_spks, spk_emb_dim)
        # æ–‡æœ¬ç¼–ç å™¨
        
        self.encoder = TextEncoder(
            encoder.encoder_type,
            encoder.encoder_params,
            encoder.duration_predictor_params,
            n_vocab,
            n_spks,
            spk_emb_dim,
        )
        
        # decoderä½¿ç”¨çš„æ˜¯CFMè¿›è¡Œè§£ç 
        self.decoder = CFM(
            in_channels=2 * encoder.encoder_params.n_feats,
            out_channel=encoder.encoder_params.n_feats,
            cfm_params=cfm,
            decoder_params=decoder,
            n_spks=n_spks,
            spk_emb_dim=spk_emb_dim,
        )

        self.update_data_statistics(data_statistics)


    #############----------noemoçš„---------------#############
    @torch.inference_mode()
    def synthesise(self, x, x_lengths,n_timesteps, temperature=1.0, spks=None, length_scale=1.0):
        """
        Generates mel-spectrogram from text. Returns:
            1. encoder outputs
            2. decoder outputs
            3. generated alignment

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            n_timesteps (int): number of steps to use for reverse diffusion in decoder.
            temperature (float, optional): controls variance of terminal distribution.
            spks (bool, optional): speaker ids.
                shape: (batch_size,)
            length_scale (float, optional): controls speech pace.
                Increase value to slow down generated speech and vice versa.

        Returns:
            dict: {
                "encoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Average mel spectrogram generated by the encoder
                "decoder_outputs": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Refined mel spectrogram improved by the CFM
                "attn": torch.Tensor, shape: (batch_size, max_text_length, max_mel_length),
                # Alignment map between text and mel spectrogram
                "mel": torch.Tensor, shape: (batch_size, n_feats, max_mel_length),
                # Denormalized mel spectrogram
                "mel_lengths": torch.Tensor, shape: (batch_size,),
                # Lengths of mel spectrograms
                "rtf": float,
                # Real-time factor
        """
        # For RTF computation
        t = dt.datetime.now()

        if self.n_spks > 1:
            # Get speaker embedding
            spks = self.spk_emb(spks.long())
        # print(f"xçš„è®¾å¤‡{x.device}")
        
        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        # å¾—åˆ°ç¼–ç å™¨è¾“å‡ºmu_xå’Œdurationçš„tokené•¿åº¦çš„å¯¹æ•°ç¼©æ”¾logw
        mu_x, logw, x_mask = self.encoder(x, x_lengths, spks)
        # print("textencoderdçš„ç»“æŸè¾“å‡º--mu", mu_x.shape)
        # print("textencoderdçš„ç»“æŸè¾“å‡º--logw", logw.shape)
        # print("textencoderdçš„ç»“æŸè¾“å‡º--x_mask", x_mask.shape)
        w = torch.exp(logw) * x_mask
        
        w_ceil = torch.ceil(w) * length_scale

        y_lengths = torch.clamp_min(torch.sum(w_ceil, [1, 2]), 1).long()

        y_max_length = y_lengths.max()
        y_max_length_ = fix_len_compatibility(y_max_length)

        # Using obtained durations `w` construct alignment map `attn`
        y_mask = sequence_mask(y_lengths, y_max_length_).unsqueeze(1).to(x_mask.dtype)
        # 
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)
        
        attn = generate_path(w_ceil.squeeze(1), attn_mask.squeeze(1)).unsqueeze(1)

        # Align encoded text and get mu_y
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2))
        mu_y = mu_y.transpose(1, 2)
        encoder_outputs = mu_y[:, :, :y_max_length]

        # Generate sample tracing the probability flow
        # ç”Ÿæˆæ¦‚ç‡æµ
        decoder_outputs = self.decoder(mu_y, y_mask, n_timesteps, temperature, spks)
        # 
        decoder_outputs = decoder_outputs[:, :, :y_max_length]
        # å®æ—¶éŸ³é¢‘é¢‘ç‡ï¼ˆRTFï¼‰
        t = (dt.datetime.now() - t).total_seconds()
        rtf = t * 22050 / (decoder_outputs.shape[-1] * 256)

        return {
            "encoder_outputs": encoder_outputs,
            "decoder_outputs": decoder_outputs,
            "attn": attn[:, :, :y_max_length],
            "mel": denormalize(decoder_outputs, self.mel_mean, self.mel_std),
            "mel_lengths": y_lengths,
            "rtf": rtf,
        }

    def forward(self, x, x_lengths, y, y_lengths, spks=None, out_size=None, cond=None, durations=None):

        """
        Computes 3 losses:
            1. duration loss: loss between predicted token durations and those extracted by Monotinic Alignment Search (MAS).

            2. prior loss: loss between mel-spectrogram and encoder outputs.
            
            3. flow matching loss: loss between mel-spectrogram and decoder outputs.

        Args:
            x (torch.Tensor): batch of texts, converted to a tensor with phoneme embedding ids.
                shape: (batch_size, max_text_length)
            x_lengths (torch.Tensor): lengths of texts in batch.
                shape: (batch_size,)
            y (torch.Tensor): batch of corresponding mel-spectrograms.
                shape: (batch_size, n_feats, max_mel_length)
            y_lengths (torch.Tensor): lengths of mel-spectrograms in batch.
                shape: (batch_size,)
            out_size (int, optional): length (in mel's sampling rate) of segment to cut, on which decoder will be trained.
                Should be divisible by 2^{num of UNet downsamplings}. Needed to increase batch size.
            spks (torch.Tensor, optional): speaker ids.
                shape: (batch_size,)
        """
        # print('matchaTTSçš„encoder')
        # è¿™é‡Œæ˜¯B*64
        if self.n_spks > 1:
            # Get speaker embedding
            spks = self.spk_emb(spks)

        # Get encoder_outputs `mu_x` and log-scaled token durations `logw`
        # å¾—åˆ°çš„æ˜¯mu_x, logw, x_mask
        # mu:æ˜¯textçš„ç‰¹å¾80ç»´,logw:æ—¶é•¿é¢„æµ‹ï¼Œæ—¶é•¿é¢„æµ‹æ¨¡å—å¾—åˆ°,è¿™é‡Œçš„æ—¶é•¿æ”¹å˜,å¯ä»¥åŠ ä¸€äº›ä¸œè¥¿ x_mask:æ©ç 
        mu_x, logw, x_mask = self.encoder(x, x_lengths,spks)
        # print('mu_xï¼ŒéŸ³éŸ³ç´ è¿›è¡Œç¼–ç ',mu_x.shape)
        # print('logwï¼Œç¼–ç åšåº¦æ—¶é•¿',logw.shape)
        
        y_max_length = y.shape[-1]
        # print('y_max_lengthï¼Œyçš„é•¿åº¦',y_max_length)
        # [4, 1, 512]
        # è®¡ç®—yçš„mask
        y_mask = sequence_mask(y_lengths, y_max_length).unsqueeze(1).to(x_mask)
        # [4, 1, 105, 512]
        # ç”Ÿæˆä¸€ä¸ªæ³¨æ„åŠ›æ©ç å¼ é‡ï¼Œç”¨äºåœ¨å¤šå¤´æ³¨æ„åŠ›æœºåˆ¶ä¸­å±è”½æ— æ•ˆçš„ä½ç½®,ä¸¤è¾¹éƒ½æœ‰æ•ˆçš„æ‰æœ‰æ•ˆ
        attn_mask = x_mask.unsqueeze(-1) * y_mask.unsqueeze(2)#[3, 1, 149, 512]

        if self.use_precomputed_durations:
            # å¦‚æœä½¿ç”¨é¢„è®¡ç®—çš„æ—¶é•¿
            attn = generate_path(durations.squeeze(1), attn_mask.squeeze(1))
        else:
            # vitsä½¿ç”¨çš„ä¹Ÿæ˜¯è¿™ä¸ªå¯¹é½çš„æ—¶é•¿
            # Use MAS to find most likely alignment `attn` between text and mel-spectrogram
            # ä½¿ç”¨ MAS å¯»æ‰¾æ–‡æœ¬ä¸æ¢…å°”é¢‘è°±å›¾ä¹‹é—´æœ€å¯èƒ½çš„å¯¹é½å›¾
            with torch.no_grad():
                # è®¡ç®—é«˜æ–¯åˆ†å¸ƒå¯¹æ•°ä¼¼ç„¶çš„ä¸€éƒ¨åˆ†
                # è®¡ç®—ä¸€ä¸ªå¸¸æ•°é¡¹ constï¼Œç”¨äºå¯¹æ•°ä¼¼ç„¶çš„è®¡ç®—ã€‚è¿™é‡Œä½¿ç”¨çš„æ˜¯é«˜æ–¯åˆ†å¸ƒçš„å¯¹æ•°ä¼¼ç„¶å…¬å¼çš„ä¸€éƒ¨åˆ†ã€‚
                const = -0.5 * math.log(2 * math.pi) * self.n_feats
                # åˆ›å»ºä¸€ä¸ªä¸ mu_x å½¢çŠ¶ç›¸åŒçš„å¼ é‡ factorï¼Œå¹¶å°†æ‰€æœ‰å…ƒç´ è®¾ç½®ä¸º -0.5ã€‚è¿™ä¸ªå¼ é‡ç”¨äºç®€åŒ–åç»­çš„è®¡ç®—
                factor = -0.5 * torch.ones(mu_x.shape, dtype=mu_x.dtype, device=mu_x.device)
                # è®¡ç®—å¼ é‡ y çš„å¹³æ–¹ä¸å¼ é‡ factor çš„ç‰¹å®šç»„åˆçš„ç‚¹ç§¯ï¼ˆdot productï¼‰
                y_square = torch.matmul(factor.transpose(1, 2), y**2)
                # è¿™ä¸€è¡Œä»£ç çš„ä½œç”¨æ˜¯è®¡ç®—å¼ é‡ mu_x ä¸ y çš„äº¤äº’é¡¹
                y_mu_double = torch.matmul(2.0 * (factor * mu_x).transpose(1, 2), y)
                # è¿™ä¸€è¡Œä»£ç çš„ä½œç”¨æ˜¯è®¡ç®—å¼ é‡ mu_x çš„å¹³æ–¹ä¸å¼ é‡ factor çš„ç‚¹ç§¯ï¼Œå¹¶å¯¹ç»“æœè¿›è¡Œæ±‚å’Œ
                mu_square = torch.sum(factor * (mu_x**2), 1).unsqueeze(-1)
                # å…¬å¼å¾—åˆ°ä¸€ä¸ªlog_priorï¼š[batch_size, seq_length_x, seq_length_y]
                log_prior = y_square - y_mu_double + mu_square + const
                # ä½œè€…è‡ªå·±å†™çš„å¯¹å…¶åŒ…ï¼Ÿï¼Ÿï¼Ÿæ²¡çœ‹
                # ä½¿ç”¨ monotonic_align.maximum_path å‡½æ•°è®¡ç®—å¯¹é½å›¾ attnã€‚
                # è¿™ä¸ªå‡½æ•°ä½¿ç”¨åŠ¨æ€è§„åˆ’ç®—æ³•æ¥æ‰¾åˆ°æœ€æœ‰å¯èƒ½çš„å¯¹é½å›¾
                # è¿™é‡Œæ˜¯å…³é”®çš„MASçš„éƒ¨åˆ†
                attn = monotonic_align.maximum_path(log_prior, attn_mask.squeeze(1))
                # å¾—åˆ°äº†ä¸€ä¸ªå¯¹é½å›¾
                attn = attn.detach()  # b, t_text, T_mel

        # print("attn:",attn)
        # Compute loss between predicted log-scaled durations and those obtained from MAS
        # refered to as prior loss in the paper
        # å…ˆéªŒæŸå¤±ï¼ˆprior lossï¼‰è¿™é‡Œè®¡ç®—å‡ºæ¥çš„æ˜¯MASçš„æŸå¤±
        logw_ = torch.log(1e-8 + torch.sum(attn.unsqueeze(1), -1)) * x_mask

        # è®¡ç®—æ—¶é•¿æŸå¤±ï¼Œå¾—åˆ°äº†ç¬¬ä¸€ä¸ªæŸå¤±ï¼ŒæŠŠæ–‡æœ¬ç¼–ç å™¨çš„é¢„æµ‹æ—¶é•¿ä¸MASå¾—åˆ°çš„æ—¶é•¿è¿›è¡Œæ¯”è¾ƒ
        # æ—¶é•¿æŸå¤±æ˜¯é€šè¿‡MASçš„å¯¹é½å›¾å¾—åˆ°çš„
        # duration loss: loss between predicted token durations and those extracted by Monotinic Alignment Search (MAS).
        dur_loss = duration_loss(logw, logw_, x_lengths)

        # è£å‰ªmelè°±ï¼Œä»¥å‡å°‘å†…å­˜å ç”¨
        # Cut a small segment of mel-spectrogram in order to increase batch size
        #   - "Hack" taken from Grad-TTS, in case of Grad-TTS, we cannot train batch size 32 on a 24GB GPU without it
        #   - Do not need this hack for Matcha-TTS, but it works with it as well
        if not isinstance(out_size, type(None)):
            max_offset = (y_lengths - out_size).clamp(0)
            offset_ranges = list(zip([0] * max_offset.shape[0], max_offset.cpu().numpy()))
            out_offset = torch.LongTensor(
                [torch.tensor(random.choice(range(start, end)) if end > start else 0) for start, end in offset_ranges]
            ).to(y_lengths)
            attn_cut = torch.zeros(attn.shape[0], attn.shape[1], out_size, dtype=attn.dtype, device=attn.device)
            y_cut = torch.zeros(y.shape[0], self.n_feats, out_size, dtype=y.dtype, device=y.device)

            y_cut_lengths = []
            for i, (y_, out_offset_) in enumerate(zip(y, out_offset)):
                y_cut_length = out_size + (y_lengths[i] - out_size).clamp(None, 0)
                y_cut_lengths.append(y_cut_length)
                cut_lower, cut_upper = out_offset_, out_offset_ + y_cut_length
                y_cut[i, :, :y_cut_length] = y_[:, cut_lower:cut_upper]
                attn_cut[i, :, :y_cut_length] = attn[i, :, cut_lower:cut_upper]

            y_cut_lengths = torch.LongTensor(y_cut_lengths)
            y_cut_mask = sequence_mask(y_cut_lengths).unsqueeze(1).to(y_mask)

            attn = attn_cut
            # yæ˜¯ä»€ä¹ˆå‘€ï¼Ÿ
            y = y_cut
            y_mask = y_cut_mask

        # print("attnçš„shape",attn.shape)
        # print("mu_xçš„shape",mu_x.shape)
        # Align encoded text with mel-spectrogram and get mu_y segment
        # è®¡ç®—æ³¨æ„åŠ›æƒé‡çŸ©é˜µä¸mu_xçš„è½¬ç½®çŸ©é˜µçš„çŸ©é˜µä¹˜ç§¯ï¼Œå¾—åˆ°mu_yï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªå¤§è‡´çš„melè°±????
        mu_y = torch.matmul(attn.squeeze(1).transpose(1, 2), mu_x.transpose(1, 2))

        # print("mu_yçš„shape",mu_y.shape)
        mu_y = mu_y.transpose(1, 2)
        # print("mu_yçš„shape",mu_y.shape)

        # Compute loss of the decoder
        # è¿™æ˜¯è®¡ç®—CFMçš„lossï¼Œè¿™é‡Œå°±æ˜¯æ¢¯åº¦ä¸‹é™çš„å…¬å¼ï¼ŒCFMçš„å…¬å¼
        # mu_yè¾“å…¥è¿›å»ï¼Œå¾—åˆ°yï¼Œç„¶åè®¡ç®—yå’Œmu_yä¹‹é—´çš„å·®å¼‚ï¼Œè¿›è¡Œå­¦ä¹ 
        # print("mu_y,å·²ç»ç»è¿‡encoderçš„å¤„ç†",mu_y.shape)#
        # print("yï¼Œæ˜¯è¾“å…¥çš„melè°±ï¼Ÿï¼Ÿï¼Œè¾“å…¥çš„melè°±",y.shape)
        # print("y_maskï¼Œæ©ç æœ‰æ•ˆæ€§",y_mask.shape)#batch*melç»´åº¦*é•¿åº¦
        # print("spksè¯´è¯äººä¿¡æ¯",spks.shape)#batch
        # print("condæ¡ä»¶",cond)
        # è¾“å…¥è¿›å»çš„éƒ½æ˜¯å•¥ã€
        # åœ¨è¿™ä¸€æ­¥æ—¶ï¼Œå¦‚æœä½¿ç”¨shortcutçš„è¯éœ€è¦ä¸“é—¨å†™shortcutçš„ç§»åŠ¨æ–¹æ³•æ¥è®¡ç®—æŸå¤±
        diff_loss, _ = self.decoder.compute_loss(x1=y, mask=y_mask, mu=mu_y, spks=spks, cond=cond)
        # é»˜è®¤æ˜¯true
        if self.prior_loss:
            prior_loss = torch.sum(0.5 * ((y - mu_y) ** 2 + math.log(2 * math.pi)) * y_mask)
            # print('æŸå¤±è®¡ç®—ï¼Œå’ŒæŸå¤±è¿”å›æ˜¯åˆ†å¼€çš„ï¼Œè¿™ä¸çŸ¥é“æ˜¯lightingçš„å†™æ³•è¿˜æ˜¯pytorchçš„å†™æ³•')
            prior_loss = prior_loss / (torch.sum(y_mask) * self.n_feats)
        else:
            prior_loss = 0

        return dur_loss, prior_loss, diff_loss, attn
